// Code generated by http://github.com/gojuno/minimock (v3.4.1). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/spv-dev/auth/internal/client/kafka.Producer -o producer_minimock.go -n ProducerMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ProducerMock implements mm_kafka.Producer
type ProducerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcClose          func() (err error)
	funcCloseOrigin    string
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mProducerMockClose

	funcSend          func(topicName string, value string) (err error)
	funcSendOrigin    string
	inspectFuncSend   func(topicName string, value string)
	afterSendCounter  uint64
	beforeSendCounter uint64
	SendMock          mProducerMockSend
}

// NewProducerMock returns a mock for mm_kafka.Producer
func NewProducerMock(t minimock.Tester) *ProducerMock {
	m := &ProducerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mProducerMockClose{mock: m}

	m.SendMock = mProducerMockSend{mock: m}
	m.SendMock.callArgs = []*ProducerMockSendParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mProducerMockClose struct {
	optional           bool
	mock               *ProducerMock
	defaultExpectation *ProducerMockCloseExpectation
	expectations       []*ProducerMockCloseExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProducerMockCloseExpectation specifies expectation struct of the Producer.Close
type ProducerMockCloseExpectation struct {
	mock *ProducerMock

	results      *ProducerMockCloseResults
	returnOrigin string
	Counter      uint64
}

// ProducerMockCloseResults contains results of the Producer.Close
type ProducerMockCloseResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClose *mProducerMockClose) Optional() *mProducerMockClose {
	mmClose.optional = true
	return mmClose
}

// Expect sets up expected params for Producer.Close
func (mmClose *mProducerMockClose) Expect() *mProducerMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ProducerMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ProducerMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the Producer.Close
func (mmClose *mProducerMockClose) Inspect(f func()) *mProducerMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for ProducerMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by Producer.Close
func (mmClose *mProducerMockClose) Return(err error) *ProducerMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ProducerMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ProducerMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &ProducerMockCloseResults{err}
	mmClose.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Set uses given function f to mock the Producer.Close method
func (mmClose *mProducerMockClose) Set(f func() (err error)) *ProducerMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the Producer.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the Producer.Close method")
	}

	mmClose.mock.funcClose = f
	mmClose.mock.funcCloseOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Times sets number of times Producer.Close should be invoked
func (mmClose *mProducerMockClose) Times(n uint64) *mProducerMockClose {
	if n == 0 {
		mmClose.mock.t.Fatalf("Times of ProducerMock.Close mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClose.expectedInvocations, n)
	mmClose.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClose
}

func (mmClose *mProducerMockClose) invocationsDone() bool {
	if len(mmClose.expectations) == 0 && mmClose.defaultExpectation == nil && mmClose.mock.funcClose == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClose.mock.afterCloseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClose.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Close implements mm_kafka.Producer
func (mmClose *ProducerMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	mmClose.t.Helper()

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the ProducerMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to ProducerMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished ProducerMock.Close invocations
func (mmClose *ProducerMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of ProducerMock.Close invocations
func (mmClose *ProducerMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *ProducerMock) MinimockCloseDone() bool {
	if m.CloseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseMock.invocationsDone()
}

// MinimockCloseInspect logs each unmet expectation
func (m *ProducerMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ProducerMock.Close")
		}
	}

	afterCloseCounter := mm_atomic.LoadUint64(&m.afterCloseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to ProducerMock.Close at\n%s", m.CloseMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to ProducerMock.Close at\n%s", m.funcCloseOrigin)
	}

	if !m.CloseMock.invocationsDone() && afterCloseCounter > 0 {
		m.t.Errorf("Expected %d calls to ProducerMock.Close at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloseMock.expectedInvocations), m.CloseMock.expectedInvocationsOrigin, afterCloseCounter)
	}
}

type mProducerMockSend struct {
	optional           bool
	mock               *ProducerMock
	defaultExpectation *ProducerMockSendExpectation
	expectations       []*ProducerMockSendExpectation

	callArgs []*ProducerMockSendParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProducerMockSendExpectation specifies expectation struct of the Producer.Send
type ProducerMockSendExpectation struct {
	mock               *ProducerMock
	params             *ProducerMockSendParams
	paramPtrs          *ProducerMockSendParamPtrs
	expectationOrigins ProducerMockSendExpectationOrigins
	results            *ProducerMockSendResults
	returnOrigin       string
	Counter            uint64
}

// ProducerMockSendParams contains parameters of the Producer.Send
type ProducerMockSendParams struct {
	topicName string
	value     string
}

// ProducerMockSendParamPtrs contains pointers to parameters of the Producer.Send
type ProducerMockSendParamPtrs struct {
	topicName *string
	value     *string
}

// ProducerMockSendResults contains results of the Producer.Send
type ProducerMockSendResults struct {
	err error
}

// ProducerMockSendOrigins contains origins of expectations of the Producer.Send
type ProducerMockSendExpectationOrigins struct {
	origin          string
	originTopicName string
	originValue     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSend *mProducerMockSend) Optional() *mProducerMockSend {
	mmSend.optional = true
	return mmSend
}

// Expect sets up expected params for Producer.Send
func (mmSend *mProducerMockSend) Expect(topicName string, value string) *mProducerMockSend {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("ProducerMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &ProducerMockSendExpectation{}
	}

	if mmSend.defaultExpectation.paramPtrs != nil {
		mmSend.mock.t.Fatalf("ProducerMock.Send mock is already set by ExpectParams functions")
	}

	mmSend.defaultExpectation.params = &ProducerMockSendParams{topicName, value}
	mmSend.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSend.expectations {
		if minimock.Equal(e.params, mmSend.defaultExpectation.params) {
			mmSend.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSend.defaultExpectation.params)
		}
	}

	return mmSend
}

// ExpectTopicNameParam1 sets up expected param topicName for Producer.Send
func (mmSend *mProducerMockSend) ExpectTopicNameParam1(topicName string) *mProducerMockSend {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("ProducerMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &ProducerMockSendExpectation{}
	}

	if mmSend.defaultExpectation.params != nil {
		mmSend.mock.t.Fatalf("ProducerMock.Send mock is already set by Expect")
	}

	if mmSend.defaultExpectation.paramPtrs == nil {
		mmSend.defaultExpectation.paramPtrs = &ProducerMockSendParamPtrs{}
	}
	mmSend.defaultExpectation.paramPtrs.topicName = &topicName
	mmSend.defaultExpectation.expectationOrigins.originTopicName = minimock.CallerInfo(1)

	return mmSend
}

// ExpectValueParam2 sets up expected param value for Producer.Send
func (mmSend *mProducerMockSend) ExpectValueParam2(value string) *mProducerMockSend {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("ProducerMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &ProducerMockSendExpectation{}
	}

	if mmSend.defaultExpectation.params != nil {
		mmSend.mock.t.Fatalf("ProducerMock.Send mock is already set by Expect")
	}

	if mmSend.defaultExpectation.paramPtrs == nil {
		mmSend.defaultExpectation.paramPtrs = &ProducerMockSendParamPtrs{}
	}
	mmSend.defaultExpectation.paramPtrs.value = &value
	mmSend.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmSend
}

// Inspect accepts an inspector function that has same arguments as the Producer.Send
func (mmSend *mProducerMockSend) Inspect(f func(topicName string, value string)) *mProducerMockSend {
	if mmSend.mock.inspectFuncSend != nil {
		mmSend.mock.t.Fatalf("Inspect function is already set for ProducerMock.Send")
	}

	mmSend.mock.inspectFuncSend = f

	return mmSend
}

// Return sets up results that will be returned by Producer.Send
func (mmSend *mProducerMockSend) Return(err error) *ProducerMock {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("ProducerMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &ProducerMockSendExpectation{mock: mmSend.mock}
	}
	mmSend.defaultExpectation.results = &ProducerMockSendResults{err}
	mmSend.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSend.mock
}

// Set uses given function f to mock the Producer.Send method
func (mmSend *mProducerMockSend) Set(f func(topicName string, value string) (err error)) *ProducerMock {
	if mmSend.defaultExpectation != nil {
		mmSend.mock.t.Fatalf("Default expectation is already set for the Producer.Send method")
	}

	if len(mmSend.expectations) > 0 {
		mmSend.mock.t.Fatalf("Some expectations are already set for the Producer.Send method")
	}

	mmSend.mock.funcSend = f
	mmSend.mock.funcSendOrigin = minimock.CallerInfo(1)
	return mmSend.mock
}

// When sets expectation for the Producer.Send which will trigger the result defined by the following
// Then helper
func (mmSend *mProducerMockSend) When(topicName string, value string) *ProducerMockSendExpectation {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("ProducerMock.Send mock is already set by Set")
	}

	expectation := &ProducerMockSendExpectation{
		mock:               mmSend.mock,
		params:             &ProducerMockSendParams{topicName, value},
		expectationOrigins: ProducerMockSendExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSend.expectations = append(mmSend.expectations, expectation)
	return expectation
}

// Then sets up Producer.Send return parameters for the expectation previously defined by the When method
func (e *ProducerMockSendExpectation) Then(err error) *ProducerMock {
	e.results = &ProducerMockSendResults{err}
	return e.mock
}

// Times sets number of times Producer.Send should be invoked
func (mmSend *mProducerMockSend) Times(n uint64) *mProducerMockSend {
	if n == 0 {
		mmSend.mock.t.Fatalf("Times of ProducerMock.Send mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSend.expectedInvocations, n)
	mmSend.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSend
}

func (mmSend *mProducerMockSend) invocationsDone() bool {
	if len(mmSend.expectations) == 0 && mmSend.defaultExpectation == nil && mmSend.mock.funcSend == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSend.mock.afterSendCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSend.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Send implements mm_kafka.Producer
func (mmSend *ProducerMock) Send(topicName string, value string) (err error) {
	mm_atomic.AddUint64(&mmSend.beforeSendCounter, 1)
	defer mm_atomic.AddUint64(&mmSend.afterSendCounter, 1)

	mmSend.t.Helper()

	if mmSend.inspectFuncSend != nil {
		mmSend.inspectFuncSend(topicName, value)
	}

	mm_params := ProducerMockSendParams{topicName, value}

	// Record call args
	mmSend.SendMock.mutex.Lock()
	mmSend.SendMock.callArgs = append(mmSend.SendMock.callArgs, &mm_params)
	mmSend.SendMock.mutex.Unlock()

	for _, e := range mmSend.SendMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSend.SendMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSend.SendMock.defaultExpectation.Counter, 1)
		mm_want := mmSend.SendMock.defaultExpectation.params
		mm_want_ptrs := mmSend.SendMock.defaultExpectation.paramPtrs

		mm_got := ProducerMockSendParams{topicName, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.topicName != nil && !minimock.Equal(*mm_want_ptrs.topicName, mm_got.topicName) {
				mmSend.t.Errorf("ProducerMock.Send got unexpected parameter topicName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSend.SendMock.defaultExpectation.expectationOrigins.originTopicName, *mm_want_ptrs.topicName, mm_got.topicName, minimock.Diff(*mm_want_ptrs.topicName, mm_got.topicName))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSend.t.Errorf("ProducerMock.Send got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSend.SendMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSend.t.Errorf("ProducerMock.Send got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSend.SendMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSend.SendMock.defaultExpectation.results
		if mm_results == nil {
			mmSend.t.Fatal("No results are set for the ProducerMock.Send")
		}
		return (*mm_results).err
	}
	if mmSend.funcSend != nil {
		return mmSend.funcSend(topicName, value)
	}
	mmSend.t.Fatalf("Unexpected call to ProducerMock.Send. %v %v", topicName, value)
	return
}

// SendAfterCounter returns a count of finished ProducerMock.Send invocations
func (mmSend *ProducerMock) SendAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSend.afterSendCounter)
}

// SendBeforeCounter returns a count of ProducerMock.Send invocations
func (mmSend *ProducerMock) SendBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSend.beforeSendCounter)
}

// Calls returns a list of arguments used in each call to ProducerMock.Send.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSend *mProducerMockSend) Calls() []*ProducerMockSendParams {
	mmSend.mutex.RLock()

	argCopy := make([]*ProducerMockSendParams, len(mmSend.callArgs))
	copy(argCopy, mmSend.callArgs)

	mmSend.mutex.RUnlock()

	return argCopy
}

// MinimockSendDone returns true if the count of the Send invocations corresponds
// the number of defined expectations
func (m *ProducerMock) MinimockSendDone() bool {
	if m.SendMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendMock.invocationsDone()
}

// MinimockSendInspect logs each unmet expectation
func (m *ProducerMock) MinimockSendInspect() {
	for _, e := range m.SendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProducerMock.Send at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendCounter := mm_atomic.LoadUint64(&m.afterSendCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendMock.defaultExpectation != nil && afterSendCounter < 1 {
		if m.SendMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProducerMock.Send at\n%s", m.SendMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProducerMock.Send at\n%s with params: %#v", m.SendMock.defaultExpectation.expectationOrigins.origin, *m.SendMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSend != nil && afterSendCounter < 1 {
		m.t.Errorf("Expected call to ProducerMock.Send at\n%s", m.funcSendOrigin)
	}

	if !m.SendMock.invocationsDone() && afterSendCounter > 0 {
		m.t.Errorf("Expected %d calls to ProducerMock.Send at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendMock.expectedInvocations), m.SendMock.expectedInvocationsOrigin, afterSendCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ProducerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCloseInspect()

			m.MinimockSendInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ProducerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ProducerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockSendDone()
}
