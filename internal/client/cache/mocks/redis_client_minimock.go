// Code generated by http://github.com/gojuno/minimock (v3.4.1). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/spv-dev/auth/internal/client/cache.RedisClient -o redis_client_minimock.go -n RedisClientMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RedisClientMock implements mm_cache.RedisClient
type RedisClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcExpire          func(ctx context.Context, key string, expiration time.Duration) (err error)
	funcExpireOrigin    string
	inspectFuncExpire   func(ctx context.Context, key string, expiration time.Duration)
	afterExpireCounter  uint64
	beforeExpireCounter uint64
	ExpireMock          mRedisClientMockExpire

	funcGet          func(ctx context.Context, key string) (p1 interface{}, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, key string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mRedisClientMockGet

	funcHGetAll          func(ctx context.Context, key string) (pa1 []interface{}, err error)
	funcHGetAllOrigin    string
	inspectFuncHGetAll   func(ctx context.Context, key string)
	afterHGetAllCounter  uint64
	beforeHGetAllCounter uint64
	HGetAllMock          mRedisClientMockHGetAll

	funcHashSet          func(ctx context.Context, key string, values interface{}) (err error)
	funcHashSetOrigin    string
	inspectFuncHashSet   func(ctx context.Context, key string, values interface{})
	afterHashSetCounter  uint64
	beforeHashSetCounter uint64
	HashSetMock          mRedisClientMockHashSet

	funcPing          func(ctx context.Context) (err error)
	funcPingOrigin    string
	inspectFuncPing   func(ctx context.Context)
	afterPingCounter  uint64
	beforePingCounter uint64
	PingMock          mRedisClientMockPing

	funcSet          func(ctx context.Context, key string, value interface{}) (err error)
	funcSetOrigin    string
	inspectFuncSet   func(ctx context.Context, key string, value interface{})
	afterSetCounter  uint64
	beforeSetCounter uint64
	SetMock          mRedisClientMockSet
}

// NewRedisClientMock returns a mock for mm_cache.RedisClient
func NewRedisClientMock(t minimock.Tester) *RedisClientMock {
	m := &RedisClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ExpireMock = mRedisClientMockExpire{mock: m}
	m.ExpireMock.callArgs = []*RedisClientMockExpireParams{}

	m.GetMock = mRedisClientMockGet{mock: m}
	m.GetMock.callArgs = []*RedisClientMockGetParams{}

	m.HGetAllMock = mRedisClientMockHGetAll{mock: m}
	m.HGetAllMock.callArgs = []*RedisClientMockHGetAllParams{}

	m.HashSetMock = mRedisClientMockHashSet{mock: m}
	m.HashSetMock.callArgs = []*RedisClientMockHashSetParams{}

	m.PingMock = mRedisClientMockPing{mock: m}
	m.PingMock.callArgs = []*RedisClientMockPingParams{}

	m.SetMock = mRedisClientMockSet{mock: m}
	m.SetMock.callArgs = []*RedisClientMockSetParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRedisClientMockExpire struct {
	optional           bool
	mock               *RedisClientMock
	defaultExpectation *RedisClientMockExpireExpectation
	expectations       []*RedisClientMockExpireExpectation

	callArgs []*RedisClientMockExpireParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RedisClientMockExpireExpectation specifies expectation struct of the RedisClient.Expire
type RedisClientMockExpireExpectation struct {
	mock               *RedisClientMock
	params             *RedisClientMockExpireParams
	paramPtrs          *RedisClientMockExpireParamPtrs
	expectationOrigins RedisClientMockExpireExpectationOrigins
	results            *RedisClientMockExpireResults
	returnOrigin       string
	Counter            uint64
}

// RedisClientMockExpireParams contains parameters of the RedisClient.Expire
type RedisClientMockExpireParams struct {
	ctx        context.Context
	key        string
	expiration time.Duration
}

// RedisClientMockExpireParamPtrs contains pointers to parameters of the RedisClient.Expire
type RedisClientMockExpireParamPtrs struct {
	ctx        *context.Context
	key        *string
	expiration *time.Duration
}

// RedisClientMockExpireResults contains results of the RedisClient.Expire
type RedisClientMockExpireResults struct {
	err error
}

// RedisClientMockExpireOrigins contains origins of expectations of the RedisClient.Expire
type RedisClientMockExpireExpectationOrigins struct {
	origin           string
	originCtx        string
	originKey        string
	originExpiration string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExpire *mRedisClientMockExpire) Optional() *mRedisClientMockExpire {
	mmExpire.optional = true
	return mmExpire
}

// Expect sets up expected params for RedisClient.Expire
func (mmExpire *mRedisClientMockExpire) Expect(ctx context.Context, key string, expiration time.Duration) *mRedisClientMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("RedisClientMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &RedisClientMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.paramPtrs != nil {
		mmExpire.mock.t.Fatalf("RedisClientMock.Expire mock is already set by ExpectParams functions")
	}

	mmExpire.defaultExpectation.params = &RedisClientMockExpireParams{ctx, key, expiration}
	mmExpire.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmExpire.expectations {
		if minimock.Equal(e.params, mmExpire.defaultExpectation.params) {
			mmExpire.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExpire.defaultExpectation.params)
		}
	}

	return mmExpire
}

// ExpectCtxParam1 sets up expected param ctx for RedisClient.Expire
func (mmExpire *mRedisClientMockExpire) ExpectCtxParam1(ctx context.Context) *mRedisClientMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("RedisClientMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &RedisClientMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.params != nil {
		mmExpire.mock.t.Fatalf("RedisClientMock.Expire mock is already set by Expect")
	}

	if mmExpire.defaultExpectation.paramPtrs == nil {
		mmExpire.defaultExpectation.paramPtrs = &RedisClientMockExpireParamPtrs{}
	}
	mmExpire.defaultExpectation.paramPtrs.ctx = &ctx
	mmExpire.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmExpire
}

// ExpectKeyParam2 sets up expected param key for RedisClient.Expire
func (mmExpire *mRedisClientMockExpire) ExpectKeyParam2(key string) *mRedisClientMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("RedisClientMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &RedisClientMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.params != nil {
		mmExpire.mock.t.Fatalf("RedisClientMock.Expire mock is already set by Expect")
	}

	if mmExpire.defaultExpectation.paramPtrs == nil {
		mmExpire.defaultExpectation.paramPtrs = &RedisClientMockExpireParamPtrs{}
	}
	mmExpire.defaultExpectation.paramPtrs.key = &key
	mmExpire.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmExpire
}

// ExpectExpirationParam3 sets up expected param expiration for RedisClient.Expire
func (mmExpire *mRedisClientMockExpire) ExpectExpirationParam3(expiration time.Duration) *mRedisClientMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("RedisClientMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &RedisClientMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.params != nil {
		mmExpire.mock.t.Fatalf("RedisClientMock.Expire mock is already set by Expect")
	}

	if mmExpire.defaultExpectation.paramPtrs == nil {
		mmExpire.defaultExpectation.paramPtrs = &RedisClientMockExpireParamPtrs{}
	}
	mmExpire.defaultExpectation.paramPtrs.expiration = &expiration
	mmExpire.defaultExpectation.expectationOrigins.originExpiration = minimock.CallerInfo(1)

	return mmExpire
}

// Inspect accepts an inspector function that has same arguments as the RedisClient.Expire
func (mmExpire *mRedisClientMockExpire) Inspect(f func(ctx context.Context, key string, expiration time.Duration)) *mRedisClientMockExpire {
	if mmExpire.mock.inspectFuncExpire != nil {
		mmExpire.mock.t.Fatalf("Inspect function is already set for RedisClientMock.Expire")
	}

	mmExpire.mock.inspectFuncExpire = f

	return mmExpire
}

// Return sets up results that will be returned by RedisClient.Expire
func (mmExpire *mRedisClientMockExpire) Return(err error) *RedisClientMock {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("RedisClientMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &RedisClientMockExpireExpectation{mock: mmExpire.mock}
	}
	mmExpire.defaultExpectation.results = &RedisClientMockExpireResults{err}
	mmExpire.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmExpire.mock
}

// Set uses given function f to mock the RedisClient.Expire method
func (mmExpire *mRedisClientMockExpire) Set(f func(ctx context.Context, key string, expiration time.Duration) (err error)) *RedisClientMock {
	if mmExpire.defaultExpectation != nil {
		mmExpire.mock.t.Fatalf("Default expectation is already set for the RedisClient.Expire method")
	}

	if len(mmExpire.expectations) > 0 {
		mmExpire.mock.t.Fatalf("Some expectations are already set for the RedisClient.Expire method")
	}

	mmExpire.mock.funcExpire = f
	mmExpire.mock.funcExpireOrigin = minimock.CallerInfo(1)
	return mmExpire.mock
}

// When sets expectation for the RedisClient.Expire which will trigger the result defined by the following
// Then helper
func (mmExpire *mRedisClientMockExpire) When(ctx context.Context, key string, expiration time.Duration) *RedisClientMockExpireExpectation {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("RedisClientMock.Expire mock is already set by Set")
	}

	expectation := &RedisClientMockExpireExpectation{
		mock:               mmExpire.mock,
		params:             &RedisClientMockExpireParams{ctx, key, expiration},
		expectationOrigins: RedisClientMockExpireExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmExpire.expectations = append(mmExpire.expectations, expectation)
	return expectation
}

// Then sets up RedisClient.Expire return parameters for the expectation previously defined by the When method
func (e *RedisClientMockExpireExpectation) Then(err error) *RedisClientMock {
	e.results = &RedisClientMockExpireResults{err}
	return e.mock
}

// Times sets number of times RedisClient.Expire should be invoked
func (mmExpire *mRedisClientMockExpire) Times(n uint64) *mRedisClientMockExpire {
	if n == 0 {
		mmExpire.mock.t.Fatalf("Times of RedisClientMock.Expire mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExpire.expectedInvocations, n)
	mmExpire.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmExpire
}

func (mmExpire *mRedisClientMockExpire) invocationsDone() bool {
	if len(mmExpire.expectations) == 0 && mmExpire.defaultExpectation == nil && mmExpire.mock.funcExpire == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExpire.mock.afterExpireCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExpire.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Expire implements mm_cache.RedisClient
func (mmExpire *RedisClientMock) Expire(ctx context.Context, key string, expiration time.Duration) (err error) {
	mm_atomic.AddUint64(&mmExpire.beforeExpireCounter, 1)
	defer mm_atomic.AddUint64(&mmExpire.afterExpireCounter, 1)

	mmExpire.t.Helper()

	if mmExpire.inspectFuncExpire != nil {
		mmExpire.inspectFuncExpire(ctx, key, expiration)
	}

	mm_params := RedisClientMockExpireParams{ctx, key, expiration}

	// Record call args
	mmExpire.ExpireMock.mutex.Lock()
	mmExpire.ExpireMock.callArgs = append(mmExpire.ExpireMock.callArgs, &mm_params)
	mmExpire.ExpireMock.mutex.Unlock()

	for _, e := range mmExpire.ExpireMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmExpire.ExpireMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExpire.ExpireMock.defaultExpectation.Counter, 1)
		mm_want := mmExpire.ExpireMock.defaultExpectation.params
		mm_want_ptrs := mmExpire.ExpireMock.defaultExpectation.paramPtrs

		mm_got := RedisClientMockExpireParams{ctx, key, expiration}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmExpire.t.Errorf("RedisClientMock.Expire got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExpire.ExpireMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmExpire.t.Errorf("RedisClientMock.Expire got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExpire.ExpireMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.expiration != nil && !minimock.Equal(*mm_want_ptrs.expiration, mm_got.expiration) {
				mmExpire.t.Errorf("RedisClientMock.Expire got unexpected parameter expiration, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExpire.ExpireMock.defaultExpectation.expectationOrigins.originExpiration, *mm_want_ptrs.expiration, mm_got.expiration, minimock.Diff(*mm_want_ptrs.expiration, mm_got.expiration))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExpire.t.Errorf("RedisClientMock.Expire got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmExpire.ExpireMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExpire.ExpireMock.defaultExpectation.results
		if mm_results == nil {
			mmExpire.t.Fatal("No results are set for the RedisClientMock.Expire")
		}
		return (*mm_results).err
	}
	if mmExpire.funcExpire != nil {
		return mmExpire.funcExpire(ctx, key, expiration)
	}
	mmExpire.t.Fatalf("Unexpected call to RedisClientMock.Expire. %v %v %v", ctx, key, expiration)
	return
}

// ExpireAfterCounter returns a count of finished RedisClientMock.Expire invocations
func (mmExpire *RedisClientMock) ExpireAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExpire.afterExpireCounter)
}

// ExpireBeforeCounter returns a count of RedisClientMock.Expire invocations
func (mmExpire *RedisClientMock) ExpireBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExpire.beforeExpireCounter)
}

// Calls returns a list of arguments used in each call to RedisClientMock.Expire.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExpire *mRedisClientMockExpire) Calls() []*RedisClientMockExpireParams {
	mmExpire.mutex.RLock()

	argCopy := make([]*RedisClientMockExpireParams, len(mmExpire.callArgs))
	copy(argCopy, mmExpire.callArgs)

	mmExpire.mutex.RUnlock()

	return argCopy
}

// MinimockExpireDone returns true if the count of the Expire invocations corresponds
// the number of defined expectations
func (m *RedisClientMock) MinimockExpireDone() bool {
	if m.ExpireMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExpireMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExpireMock.invocationsDone()
}

// MinimockExpireInspect logs each unmet expectation
func (m *RedisClientMock) MinimockExpireInspect() {
	for _, e := range m.ExpireMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RedisClientMock.Expire at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterExpireCounter := mm_atomic.LoadUint64(&m.afterExpireCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExpireMock.defaultExpectation != nil && afterExpireCounter < 1 {
		if m.ExpireMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RedisClientMock.Expire at\n%s", m.ExpireMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RedisClientMock.Expire at\n%s with params: %#v", m.ExpireMock.defaultExpectation.expectationOrigins.origin, *m.ExpireMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExpire != nil && afterExpireCounter < 1 {
		m.t.Errorf("Expected call to RedisClientMock.Expire at\n%s", m.funcExpireOrigin)
	}

	if !m.ExpireMock.invocationsDone() && afterExpireCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisClientMock.Expire at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ExpireMock.expectedInvocations), m.ExpireMock.expectedInvocationsOrigin, afterExpireCounter)
	}
}

type mRedisClientMockGet struct {
	optional           bool
	mock               *RedisClientMock
	defaultExpectation *RedisClientMockGetExpectation
	expectations       []*RedisClientMockGetExpectation

	callArgs []*RedisClientMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RedisClientMockGetExpectation specifies expectation struct of the RedisClient.Get
type RedisClientMockGetExpectation struct {
	mock               *RedisClientMock
	params             *RedisClientMockGetParams
	paramPtrs          *RedisClientMockGetParamPtrs
	expectationOrigins RedisClientMockGetExpectationOrigins
	results            *RedisClientMockGetResults
	returnOrigin       string
	Counter            uint64
}

// RedisClientMockGetParams contains parameters of the RedisClient.Get
type RedisClientMockGetParams struct {
	ctx context.Context
	key string
}

// RedisClientMockGetParamPtrs contains pointers to parameters of the RedisClient.Get
type RedisClientMockGetParamPtrs struct {
	ctx *context.Context
	key *string
}

// RedisClientMockGetResults contains results of the RedisClient.Get
type RedisClientMockGetResults struct {
	p1  interface{}
	err error
}

// RedisClientMockGetOrigins contains origins of expectations of the RedisClient.Get
type RedisClientMockGetExpectationOrigins struct {
	origin    string
	originCtx string
	originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mRedisClientMockGet) Optional() *mRedisClientMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for RedisClient.Get
func (mmGet *mRedisClientMockGet) Expect(ctx context.Context, key string) *mRedisClientMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RedisClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &RedisClientMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("RedisClientMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &RedisClientMockGetParams{ctx, key}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for RedisClient.Get
func (mmGet *mRedisClientMockGet) ExpectCtxParam1(ctx context.Context) *mRedisClientMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RedisClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &RedisClientMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("RedisClientMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &RedisClientMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectKeyParam2 sets up expected param key for RedisClient.Get
func (mmGet *mRedisClientMockGet) ExpectKeyParam2(key string) *mRedisClientMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RedisClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &RedisClientMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("RedisClientMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &RedisClientMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.key = &key
	mmGet.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the RedisClient.Get
func (mmGet *mRedisClientMockGet) Inspect(f func(ctx context.Context, key string)) *mRedisClientMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for RedisClientMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by RedisClient.Get
func (mmGet *mRedisClientMockGet) Return(p1 interface{}, err error) *RedisClientMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RedisClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &RedisClientMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &RedisClientMockGetResults{p1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the RedisClient.Get method
func (mmGet *mRedisClientMockGet) Set(f func(ctx context.Context, key string) (p1 interface{}, err error)) *RedisClientMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the RedisClient.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the RedisClient.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the RedisClient.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mRedisClientMockGet) When(ctx context.Context, key string) *RedisClientMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RedisClientMock.Get mock is already set by Set")
	}

	expectation := &RedisClientMockGetExpectation{
		mock:               mmGet.mock,
		params:             &RedisClientMockGetParams{ctx, key},
		expectationOrigins: RedisClientMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up RedisClient.Get return parameters for the expectation previously defined by the When method
func (e *RedisClientMockGetExpectation) Then(p1 interface{}, err error) *RedisClientMock {
	e.results = &RedisClientMockGetResults{p1, err}
	return e.mock
}

// Times sets number of times RedisClient.Get should be invoked
func (mmGet *mRedisClientMockGet) Times(n uint64) *mRedisClientMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of RedisClientMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mRedisClientMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_cache.RedisClient
func (mmGet *RedisClientMock) Get(ctx context.Context, key string) (p1 interface{}, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, key)
	}

	mm_params := RedisClientMockGetParams{ctx, key}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := RedisClientMockGetParams{ctx, key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("RedisClientMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmGet.t.Errorf("RedisClientMock.Get got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("RedisClientMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the RedisClientMock.Get")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, key)
	}
	mmGet.t.Fatalf("Unexpected call to RedisClientMock.Get. %v %v", ctx, key)
	return
}

// GetAfterCounter returns a count of finished RedisClientMock.Get invocations
func (mmGet *RedisClientMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of RedisClientMock.Get invocations
func (mmGet *RedisClientMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to RedisClientMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mRedisClientMockGet) Calls() []*RedisClientMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*RedisClientMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *RedisClientMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *RedisClientMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RedisClientMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RedisClientMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RedisClientMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to RedisClientMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisClientMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mRedisClientMockHGetAll struct {
	optional           bool
	mock               *RedisClientMock
	defaultExpectation *RedisClientMockHGetAllExpectation
	expectations       []*RedisClientMockHGetAllExpectation

	callArgs []*RedisClientMockHGetAllParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RedisClientMockHGetAllExpectation specifies expectation struct of the RedisClient.HGetAll
type RedisClientMockHGetAllExpectation struct {
	mock               *RedisClientMock
	params             *RedisClientMockHGetAllParams
	paramPtrs          *RedisClientMockHGetAllParamPtrs
	expectationOrigins RedisClientMockHGetAllExpectationOrigins
	results            *RedisClientMockHGetAllResults
	returnOrigin       string
	Counter            uint64
}

// RedisClientMockHGetAllParams contains parameters of the RedisClient.HGetAll
type RedisClientMockHGetAllParams struct {
	ctx context.Context
	key string
}

// RedisClientMockHGetAllParamPtrs contains pointers to parameters of the RedisClient.HGetAll
type RedisClientMockHGetAllParamPtrs struct {
	ctx *context.Context
	key *string
}

// RedisClientMockHGetAllResults contains results of the RedisClient.HGetAll
type RedisClientMockHGetAllResults struct {
	pa1 []interface{}
	err error
}

// RedisClientMockHGetAllOrigins contains origins of expectations of the RedisClient.HGetAll
type RedisClientMockHGetAllExpectationOrigins struct {
	origin    string
	originCtx string
	originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHGetAll *mRedisClientMockHGetAll) Optional() *mRedisClientMockHGetAll {
	mmHGetAll.optional = true
	return mmHGetAll
}

// Expect sets up expected params for RedisClient.HGetAll
func (mmHGetAll *mRedisClientMockHGetAll) Expect(ctx context.Context, key string) *mRedisClientMockHGetAll {
	if mmHGetAll.mock.funcHGetAll != nil {
		mmHGetAll.mock.t.Fatalf("RedisClientMock.HGetAll mock is already set by Set")
	}

	if mmHGetAll.defaultExpectation == nil {
		mmHGetAll.defaultExpectation = &RedisClientMockHGetAllExpectation{}
	}

	if mmHGetAll.defaultExpectation.paramPtrs != nil {
		mmHGetAll.mock.t.Fatalf("RedisClientMock.HGetAll mock is already set by ExpectParams functions")
	}

	mmHGetAll.defaultExpectation.params = &RedisClientMockHGetAllParams{ctx, key}
	mmHGetAll.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHGetAll.expectations {
		if minimock.Equal(e.params, mmHGetAll.defaultExpectation.params) {
			mmHGetAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHGetAll.defaultExpectation.params)
		}
	}

	return mmHGetAll
}

// ExpectCtxParam1 sets up expected param ctx for RedisClient.HGetAll
func (mmHGetAll *mRedisClientMockHGetAll) ExpectCtxParam1(ctx context.Context) *mRedisClientMockHGetAll {
	if mmHGetAll.mock.funcHGetAll != nil {
		mmHGetAll.mock.t.Fatalf("RedisClientMock.HGetAll mock is already set by Set")
	}

	if mmHGetAll.defaultExpectation == nil {
		mmHGetAll.defaultExpectation = &RedisClientMockHGetAllExpectation{}
	}

	if mmHGetAll.defaultExpectation.params != nil {
		mmHGetAll.mock.t.Fatalf("RedisClientMock.HGetAll mock is already set by Expect")
	}

	if mmHGetAll.defaultExpectation.paramPtrs == nil {
		mmHGetAll.defaultExpectation.paramPtrs = &RedisClientMockHGetAllParamPtrs{}
	}
	mmHGetAll.defaultExpectation.paramPtrs.ctx = &ctx
	mmHGetAll.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHGetAll
}

// ExpectKeyParam2 sets up expected param key for RedisClient.HGetAll
func (mmHGetAll *mRedisClientMockHGetAll) ExpectKeyParam2(key string) *mRedisClientMockHGetAll {
	if mmHGetAll.mock.funcHGetAll != nil {
		mmHGetAll.mock.t.Fatalf("RedisClientMock.HGetAll mock is already set by Set")
	}

	if mmHGetAll.defaultExpectation == nil {
		mmHGetAll.defaultExpectation = &RedisClientMockHGetAllExpectation{}
	}

	if mmHGetAll.defaultExpectation.params != nil {
		mmHGetAll.mock.t.Fatalf("RedisClientMock.HGetAll mock is already set by Expect")
	}

	if mmHGetAll.defaultExpectation.paramPtrs == nil {
		mmHGetAll.defaultExpectation.paramPtrs = &RedisClientMockHGetAllParamPtrs{}
	}
	mmHGetAll.defaultExpectation.paramPtrs.key = &key
	mmHGetAll.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmHGetAll
}

// Inspect accepts an inspector function that has same arguments as the RedisClient.HGetAll
func (mmHGetAll *mRedisClientMockHGetAll) Inspect(f func(ctx context.Context, key string)) *mRedisClientMockHGetAll {
	if mmHGetAll.mock.inspectFuncHGetAll != nil {
		mmHGetAll.mock.t.Fatalf("Inspect function is already set for RedisClientMock.HGetAll")
	}

	mmHGetAll.mock.inspectFuncHGetAll = f

	return mmHGetAll
}

// Return sets up results that will be returned by RedisClient.HGetAll
func (mmHGetAll *mRedisClientMockHGetAll) Return(pa1 []interface{}, err error) *RedisClientMock {
	if mmHGetAll.mock.funcHGetAll != nil {
		mmHGetAll.mock.t.Fatalf("RedisClientMock.HGetAll mock is already set by Set")
	}

	if mmHGetAll.defaultExpectation == nil {
		mmHGetAll.defaultExpectation = &RedisClientMockHGetAllExpectation{mock: mmHGetAll.mock}
	}
	mmHGetAll.defaultExpectation.results = &RedisClientMockHGetAllResults{pa1, err}
	mmHGetAll.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHGetAll.mock
}

// Set uses given function f to mock the RedisClient.HGetAll method
func (mmHGetAll *mRedisClientMockHGetAll) Set(f func(ctx context.Context, key string) (pa1 []interface{}, err error)) *RedisClientMock {
	if mmHGetAll.defaultExpectation != nil {
		mmHGetAll.mock.t.Fatalf("Default expectation is already set for the RedisClient.HGetAll method")
	}

	if len(mmHGetAll.expectations) > 0 {
		mmHGetAll.mock.t.Fatalf("Some expectations are already set for the RedisClient.HGetAll method")
	}

	mmHGetAll.mock.funcHGetAll = f
	mmHGetAll.mock.funcHGetAllOrigin = minimock.CallerInfo(1)
	return mmHGetAll.mock
}

// When sets expectation for the RedisClient.HGetAll which will trigger the result defined by the following
// Then helper
func (mmHGetAll *mRedisClientMockHGetAll) When(ctx context.Context, key string) *RedisClientMockHGetAllExpectation {
	if mmHGetAll.mock.funcHGetAll != nil {
		mmHGetAll.mock.t.Fatalf("RedisClientMock.HGetAll mock is already set by Set")
	}

	expectation := &RedisClientMockHGetAllExpectation{
		mock:               mmHGetAll.mock,
		params:             &RedisClientMockHGetAllParams{ctx, key},
		expectationOrigins: RedisClientMockHGetAllExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHGetAll.expectations = append(mmHGetAll.expectations, expectation)
	return expectation
}

// Then sets up RedisClient.HGetAll return parameters for the expectation previously defined by the When method
func (e *RedisClientMockHGetAllExpectation) Then(pa1 []interface{}, err error) *RedisClientMock {
	e.results = &RedisClientMockHGetAllResults{pa1, err}
	return e.mock
}

// Times sets number of times RedisClient.HGetAll should be invoked
func (mmHGetAll *mRedisClientMockHGetAll) Times(n uint64) *mRedisClientMockHGetAll {
	if n == 0 {
		mmHGetAll.mock.t.Fatalf("Times of RedisClientMock.HGetAll mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHGetAll.expectedInvocations, n)
	mmHGetAll.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHGetAll
}

func (mmHGetAll *mRedisClientMockHGetAll) invocationsDone() bool {
	if len(mmHGetAll.expectations) == 0 && mmHGetAll.defaultExpectation == nil && mmHGetAll.mock.funcHGetAll == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHGetAll.mock.afterHGetAllCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHGetAll.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HGetAll implements mm_cache.RedisClient
func (mmHGetAll *RedisClientMock) HGetAll(ctx context.Context, key string) (pa1 []interface{}, err error) {
	mm_atomic.AddUint64(&mmHGetAll.beforeHGetAllCounter, 1)
	defer mm_atomic.AddUint64(&mmHGetAll.afterHGetAllCounter, 1)

	mmHGetAll.t.Helper()

	if mmHGetAll.inspectFuncHGetAll != nil {
		mmHGetAll.inspectFuncHGetAll(ctx, key)
	}

	mm_params := RedisClientMockHGetAllParams{ctx, key}

	// Record call args
	mmHGetAll.HGetAllMock.mutex.Lock()
	mmHGetAll.HGetAllMock.callArgs = append(mmHGetAll.HGetAllMock.callArgs, &mm_params)
	mmHGetAll.HGetAllMock.mutex.Unlock()

	for _, e := range mmHGetAll.HGetAllMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmHGetAll.HGetAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHGetAll.HGetAllMock.defaultExpectation.Counter, 1)
		mm_want := mmHGetAll.HGetAllMock.defaultExpectation.params
		mm_want_ptrs := mmHGetAll.HGetAllMock.defaultExpectation.paramPtrs

		mm_got := RedisClientMockHGetAllParams{ctx, key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHGetAll.t.Errorf("RedisClientMock.HGetAll got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHGetAll.HGetAllMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmHGetAll.t.Errorf("RedisClientMock.HGetAll got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHGetAll.HGetAllMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHGetAll.t.Errorf("RedisClientMock.HGetAll got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHGetAll.HGetAllMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHGetAll.HGetAllMock.defaultExpectation.results
		if mm_results == nil {
			mmHGetAll.t.Fatal("No results are set for the RedisClientMock.HGetAll")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmHGetAll.funcHGetAll != nil {
		return mmHGetAll.funcHGetAll(ctx, key)
	}
	mmHGetAll.t.Fatalf("Unexpected call to RedisClientMock.HGetAll. %v %v", ctx, key)
	return
}

// HGetAllAfterCounter returns a count of finished RedisClientMock.HGetAll invocations
func (mmHGetAll *RedisClientMock) HGetAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHGetAll.afterHGetAllCounter)
}

// HGetAllBeforeCounter returns a count of RedisClientMock.HGetAll invocations
func (mmHGetAll *RedisClientMock) HGetAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHGetAll.beforeHGetAllCounter)
}

// Calls returns a list of arguments used in each call to RedisClientMock.HGetAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHGetAll *mRedisClientMockHGetAll) Calls() []*RedisClientMockHGetAllParams {
	mmHGetAll.mutex.RLock()

	argCopy := make([]*RedisClientMockHGetAllParams, len(mmHGetAll.callArgs))
	copy(argCopy, mmHGetAll.callArgs)

	mmHGetAll.mutex.RUnlock()

	return argCopy
}

// MinimockHGetAllDone returns true if the count of the HGetAll invocations corresponds
// the number of defined expectations
func (m *RedisClientMock) MinimockHGetAllDone() bool {
	if m.HGetAllMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HGetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HGetAllMock.invocationsDone()
}

// MinimockHGetAllInspect logs each unmet expectation
func (m *RedisClientMock) MinimockHGetAllInspect() {
	for _, e := range m.HGetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RedisClientMock.HGetAll at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHGetAllCounter := mm_atomic.LoadUint64(&m.afterHGetAllCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HGetAllMock.defaultExpectation != nil && afterHGetAllCounter < 1 {
		if m.HGetAllMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RedisClientMock.HGetAll at\n%s", m.HGetAllMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RedisClientMock.HGetAll at\n%s with params: %#v", m.HGetAllMock.defaultExpectation.expectationOrigins.origin, *m.HGetAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHGetAll != nil && afterHGetAllCounter < 1 {
		m.t.Errorf("Expected call to RedisClientMock.HGetAll at\n%s", m.funcHGetAllOrigin)
	}

	if !m.HGetAllMock.invocationsDone() && afterHGetAllCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisClientMock.HGetAll at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HGetAllMock.expectedInvocations), m.HGetAllMock.expectedInvocationsOrigin, afterHGetAllCounter)
	}
}

type mRedisClientMockHashSet struct {
	optional           bool
	mock               *RedisClientMock
	defaultExpectation *RedisClientMockHashSetExpectation
	expectations       []*RedisClientMockHashSetExpectation

	callArgs []*RedisClientMockHashSetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RedisClientMockHashSetExpectation specifies expectation struct of the RedisClient.HashSet
type RedisClientMockHashSetExpectation struct {
	mock               *RedisClientMock
	params             *RedisClientMockHashSetParams
	paramPtrs          *RedisClientMockHashSetParamPtrs
	expectationOrigins RedisClientMockHashSetExpectationOrigins
	results            *RedisClientMockHashSetResults
	returnOrigin       string
	Counter            uint64
}

// RedisClientMockHashSetParams contains parameters of the RedisClient.HashSet
type RedisClientMockHashSetParams struct {
	ctx    context.Context
	key    string
	values interface{}
}

// RedisClientMockHashSetParamPtrs contains pointers to parameters of the RedisClient.HashSet
type RedisClientMockHashSetParamPtrs struct {
	ctx    *context.Context
	key    *string
	values *interface{}
}

// RedisClientMockHashSetResults contains results of the RedisClient.HashSet
type RedisClientMockHashSetResults struct {
	err error
}

// RedisClientMockHashSetOrigins contains origins of expectations of the RedisClient.HashSet
type RedisClientMockHashSetExpectationOrigins struct {
	origin       string
	originCtx    string
	originKey    string
	originValues string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHashSet *mRedisClientMockHashSet) Optional() *mRedisClientMockHashSet {
	mmHashSet.optional = true
	return mmHashSet
}

// Expect sets up expected params for RedisClient.HashSet
func (mmHashSet *mRedisClientMockHashSet) Expect(ctx context.Context, key string, values interface{}) *mRedisClientMockHashSet {
	if mmHashSet.mock.funcHashSet != nil {
		mmHashSet.mock.t.Fatalf("RedisClientMock.HashSet mock is already set by Set")
	}

	if mmHashSet.defaultExpectation == nil {
		mmHashSet.defaultExpectation = &RedisClientMockHashSetExpectation{}
	}

	if mmHashSet.defaultExpectation.paramPtrs != nil {
		mmHashSet.mock.t.Fatalf("RedisClientMock.HashSet mock is already set by ExpectParams functions")
	}

	mmHashSet.defaultExpectation.params = &RedisClientMockHashSetParams{ctx, key, values}
	mmHashSet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHashSet.expectations {
		if minimock.Equal(e.params, mmHashSet.defaultExpectation.params) {
			mmHashSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHashSet.defaultExpectation.params)
		}
	}

	return mmHashSet
}

// ExpectCtxParam1 sets up expected param ctx for RedisClient.HashSet
func (mmHashSet *mRedisClientMockHashSet) ExpectCtxParam1(ctx context.Context) *mRedisClientMockHashSet {
	if mmHashSet.mock.funcHashSet != nil {
		mmHashSet.mock.t.Fatalf("RedisClientMock.HashSet mock is already set by Set")
	}

	if mmHashSet.defaultExpectation == nil {
		mmHashSet.defaultExpectation = &RedisClientMockHashSetExpectation{}
	}

	if mmHashSet.defaultExpectation.params != nil {
		mmHashSet.mock.t.Fatalf("RedisClientMock.HashSet mock is already set by Expect")
	}

	if mmHashSet.defaultExpectation.paramPtrs == nil {
		mmHashSet.defaultExpectation.paramPtrs = &RedisClientMockHashSetParamPtrs{}
	}
	mmHashSet.defaultExpectation.paramPtrs.ctx = &ctx
	mmHashSet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHashSet
}

// ExpectKeyParam2 sets up expected param key for RedisClient.HashSet
func (mmHashSet *mRedisClientMockHashSet) ExpectKeyParam2(key string) *mRedisClientMockHashSet {
	if mmHashSet.mock.funcHashSet != nil {
		mmHashSet.mock.t.Fatalf("RedisClientMock.HashSet mock is already set by Set")
	}

	if mmHashSet.defaultExpectation == nil {
		mmHashSet.defaultExpectation = &RedisClientMockHashSetExpectation{}
	}

	if mmHashSet.defaultExpectation.params != nil {
		mmHashSet.mock.t.Fatalf("RedisClientMock.HashSet mock is already set by Expect")
	}

	if mmHashSet.defaultExpectation.paramPtrs == nil {
		mmHashSet.defaultExpectation.paramPtrs = &RedisClientMockHashSetParamPtrs{}
	}
	mmHashSet.defaultExpectation.paramPtrs.key = &key
	mmHashSet.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmHashSet
}

// ExpectValuesParam3 sets up expected param values for RedisClient.HashSet
func (mmHashSet *mRedisClientMockHashSet) ExpectValuesParam3(values interface{}) *mRedisClientMockHashSet {
	if mmHashSet.mock.funcHashSet != nil {
		mmHashSet.mock.t.Fatalf("RedisClientMock.HashSet mock is already set by Set")
	}

	if mmHashSet.defaultExpectation == nil {
		mmHashSet.defaultExpectation = &RedisClientMockHashSetExpectation{}
	}

	if mmHashSet.defaultExpectation.params != nil {
		mmHashSet.mock.t.Fatalf("RedisClientMock.HashSet mock is already set by Expect")
	}

	if mmHashSet.defaultExpectation.paramPtrs == nil {
		mmHashSet.defaultExpectation.paramPtrs = &RedisClientMockHashSetParamPtrs{}
	}
	mmHashSet.defaultExpectation.paramPtrs.values = &values
	mmHashSet.defaultExpectation.expectationOrigins.originValues = minimock.CallerInfo(1)

	return mmHashSet
}

// Inspect accepts an inspector function that has same arguments as the RedisClient.HashSet
func (mmHashSet *mRedisClientMockHashSet) Inspect(f func(ctx context.Context, key string, values interface{})) *mRedisClientMockHashSet {
	if mmHashSet.mock.inspectFuncHashSet != nil {
		mmHashSet.mock.t.Fatalf("Inspect function is already set for RedisClientMock.HashSet")
	}

	mmHashSet.mock.inspectFuncHashSet = f

	return mmHashSet
}

// Return sets up results that will be returned by RedisClient.HashSet
func (mmHashSet *mRedisClientMockHashSet) Return(err error) *RedisClientMock {
	if mmHashSet.mock.funcHashSet != nil {
		mmHashSet.mock.t.Fatalf("RedisClientMock.HashSet mock is already set by Set")
	}

	if mmHashSet.defaultExpectation == nil {
		mmHashSet.defaultExpectation = &RedisClientMockHashSetExpectation{mock: mmHashSet.mock}
	}
	mmHashSet.defaultExpectation.results = &RedisClientMockHashSetResults{err}
	mmHashSet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHashSet.mock
}

// Set uses given function f to mock the RedisClient.HashSet method
func (mmHashSet *mRedisClientMockHashSet) Set(f func(ctx context.Context, key string, values interface{}) (err error)) *RedisClientMock {
	if mmHashSet.defaultExpectation != nil {
		mmHashSet.mock.t.Fatalf("Default expectation is already set for the RedisClient.HashSet method")
	}

	if len(mmHashSet.expectations) > 0 {
		mmHashSet.mock.t.Fatalf("Some expectations are already set for the RedisClient.HashSet method")
	}

	mmHashSet.mock.funcHashSet = f
	mmHashSet.mock.funcHashSetOrigin = minimock.CallerInfo(1)
	return mmHashSet.mock
}

// When sets expectation for the RedisClient.HashSet which will trigger the result defined by the following
// Then helper
func (mmHashSet *mRedisClientMockHashSet) When(ctx context.Context, key string, values interface{}) *RedisClientMockHashSetExpectation {
	if mmHashSet.mock.funcHashSet != nil {
		mmHashSet.mock.t.Fatalf("RedisClientMock.HashSet mock is already set by Set")
	}

	expectation := &RedisClientMockHashSetExpectation{
		mock:               mmHashSet.mock,
		params:             &RedisClientMockHashSetParams{ctx, key, values},
		expectationOrigins: RedisClientMockHashSetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHashSet.expectations = append(mmHashSet.expectations, expectation)
	return expectation
}

// Then sets up RedisClient.HashSet return parameters for the expectation previously defined by the When method
func (e *RedisClientMockHashSetExpectation) Then(err error) *RedisClientMock {
	e.results = &RedisClientMockHashSetResults{err}
	return e.mock
}

// Times sets number of times RedisClient.HashSet should be invoked
func (mmHashSet *mRedisClientMockHashSet) Times(n uint64) *mRedisClientMockHashSet {
	if n == 0 {
		mmHashSet.mock.t.Fatalf("Times of RedisClientMock.HashSet mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHashSet.expectedInvocations, n)
	mmHashSet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHashSet
}

func (mmHashSet *mRedisClientMockHashSet) invocationsDone() bool {
	if len(mmHashSet.expectations) == 0 && mmHashSet.defaultExpectation == nil && mmHashSet.mock.funcHashSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHashSet.mock.afterHashSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHashSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HashSet implements mm_cache.RedisClient
func (mmHashSet *RedisClientMock) HashSet(ctx context.Context, key string, values interface{}) (err error) {
	mm_atomic.AddUint64(&mmHashSet.beforeHashSetCounter, 1)
	defer mm_atomic.AddUint64(&mmHashSet.afterHashSetCounter, 1)

	mmHashSet.t.Helper()

	if mmHashSet.inspectFuncHashSet != nil {
		mmHashSet.inspectFuncHashSet(ctx, key, values)
	}

	mm_params := RedisClientMockHashSetParams{ctx, key, values}

	// Record call args
	mmHashSet.HashSetMock.mutex.Lock()
	mmHashSet.HashSetMock.callArgs = append(mmHashSet.HashSetMock.callArgs, &mm_params)
	mmHashSet.HashSetMock.mutex.Unlock()

	for _, e := range mmHashSet.HashSetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHashSet.HashSetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHashSet.HashSetMock.defaultExpectation.Counter, 1)
		mm_want := mmHashSet.HashSetMock.defaultExpectation.params
		mm_want_ptrs := mmHashSet.HashSetMock.defaultExpectation.paramPtrs

		mm_got := RedisClientMockHashSetParams{ctx, key, values}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHashSet.t.Errorf("RedisClientMock.HashSet got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHashSet.HashSetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmHashSet.t.Errorf("RedisClientMock.HashSet got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHashSet.HashSetMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.values != nil && !minimock.Equal(*mm_want_ptrs.values, mm_got.values) {
				mmHashSet.t.Errorf("RedisClientMock.HashSet got unexpected parameter values, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHashSet.HashSetMock.defaultExpectation.expectationOrigins.originValues, *mm_want_ptrs.values, mm_got.values, minimock.Diff(*mm_want_ptrs.values, mm_got.values))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHashSet.t.Errorf("RedisClientMock.HashSet got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHashSet.HashSetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHashSet.HashSetMock.defaultExpectation.results
		if mm_results == nil {
			mmHashSet.t.Fatal("No results are set for the RedisClientMock.HashSet")
		}
		return (*mm_results).err
	}
	if mmHashSet.funcHashSet != nil {
		return mmHashSet.funcHashSet(ctx, key, values)
	}
	mmHashSet.t.Fatalf("Unexpected call to RedisClientMock.HashSet. %v %v %v", ctx, key, values)
	return
}

// HashSetAfterCounter returns a count of finished RedisClientMock.HashSet invocations
func (mmHashSet *RedisClientMock) HashSetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHashSet.afterHashSetCounter)
}

// HashSetBeforeCounter returns a count of RedisClientMock.HashSet invocations
func (mmHashSet *RedisClientMock) HashSetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHashSet.beforeHashSetCounter)
}

// Calls returns a list of arguments used in each call to RedisClientMock.HashSet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHashSet *mRedisClientMockHashSet) Calls() []*RedisClientMockHashSetParams {
	mmHashSet.mutex.RLock()

	argCopy := make([]*RedisClientMockHashSetParams, len(mmHashSet.callArgs))
	copy(argCopy, mmHashSet.callArgs)

	mmHashSet.mutex.RUnlock()

	return argCopy
}

// MinimockHashSetDone returns true if the count of the HashSet invocations corresponds
// the number of defined expectations
func (m *RedisClientMock) MinimockHashSetDone() bool {
	if m.HashSetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HashSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HashSetMock.invocationsDone()
}

// MinimockHashSetInspect logs each unmet expectation
func (m *RedisClientMock) MinimockHashSetInspect() {
	for _, e := range m.HashSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RedisClientMock.HashSet at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHashSetCounter := mm_atomic.LoadUint64(&m.afterHashSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HashSetMock.defaultExpectation != nil && afterHashSetCounter < 1 {
		if m.HashSetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RedisClientMock.HashSet at\n%s", m.HashSetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RedisClientMock.HashSet at\n%s with params: %#v", m.HashSetMock.defaultExpectation.expectationOrigins.origin, *m.HashSetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHashSet != nil && afterHashSetCounter < 1 {
		m.t.Errorf("Expected call to RedisClientMock.HashSet at\n%s", m.funcHashSetOrigin)
	}

	if !m.HashSetMock.invocationsDone() && afterHashSetCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisClientMock.HashSet at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HashSetMock.expectedInvocations), m.HashSetMock.expectedInvocationsOrigin, afterHashSetCounter)
	}
}

type mRedisClientMockPing struct {
	optional           bool
	mock               *RedisClientMock
	defaultExpectation *RedisClientMockPingExpectation
	expectations       []*RedisClientMockPingExpectation

	callArgs []*RedisClientMockPingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RedisClientMockPingExpectation specifies expectation struct of the RedisClient.Ping
type RedisClientMockPingExpectation struct {
	mock               *RedisClientMock
	params             *RedisClientMockPingParams
	paramPtrs          *RedisClientMockPingParamPtrs
	expectationOrigins RedisClientMockPingExpectationOrigins
	results            *RedisClientMockPingResults
	returnOrigin       string
	Counter            uint64
}

// RedisClientMockPingParams contains parameters of the RedisClient.Ping
type RedisClientMockPingParams struct {
	ctx context.Context
}

// RedisClientMockPingParamPtrs contains pointers to parameters of the RedisClient.Ping
type RedisClientMockPingParamPtrs struct {
	ctx *context.Context
}

// RedisClientMockPingResults contains results of the RedisClient.Ping
type RedisClientMockPingResults struct {
	err error
}

// RedisClientMockPingOrigins contains origins of expectations of the RedisClient.Ping
type RedisClientMockPingExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPing *mRedisClientMockPing) Optional() *mRedisClientMockPing {
	mmPing.optional = true
	return mmPing
}

// Expect sets up expected params for RedisClient.Ping
func (mmPing *mRedisClientMockPing) Expect(ctx context.Context) *mRedisClientMockPing {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("RedisClientMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &RedisClientMockPingExpectation{}
	}

	if mmPing.defaultExpectation.paramPtrs != nil {
		mmPing.mock.t.Fatalf("RedisClientMock.Ping mock is already set by ExpectParams functions")
	}

	mmPing.defaultExpectation.params = &RedisClientMockPingParams{ctx}
	mmPing.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPing.expectations {
		if minimock.Equal(e.params, mmPing.defaultExpectation.params) {
			mmPing.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPing.defaultExpectation.params)
		}
	}

	return mmPing
}

// ExpectCtxParam1 sets up expected param ctx for RedisClient.Ping
func (mmPing *mRedisClientMockPing) ExpectCtxParam1(ctx context.Context) *mRedisClientMockPing {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("RedisClientMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &RedisClientMockPingExpectation{}
	}

	if mmPing.defaultExpectation.params != nil {
		mmPing.mock.t.Fatalf("RedisClientMock.Ping mock is already set by Expect")
	}

	if mmPing.defaultExpectation.paramPtrs == nil {
		mmPing.defaultExpectation.paramPtrs = &RedisClientMockPingParamPtrs{}
	}
	mmPing.defaultExpectation.paramPtrs.ctx = &ctx
	mmPing.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPing
}

// Inspect accepts an inspector function that has same arguments as the RedisClient.Ping
func (mmPing *mRedisClientMockPing) Inspect(f func(ctx context.Context)) *mRedisClientMockPing {
	if mmPing.mock.inspectFuncPing != nil {
		mmPing.mock.t.Fatalf("Inspect function is already set for RedisClientMock.Ping")
	}

	mmPing.mock.inspectFuncPing = f

	return mmPing
}

// Return sets up results that will be returned by RedisClient.Ping
func (mmPing *mRedisClientMockPing) Return(err error) *RedisClientMock {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("RedisClientMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &RedisClientMockPingExpectation{mock: mmPing.mock}
	}
	mmPing.defaultExpectation.results = &RedisClientMockPingResults{err}
	mmPing.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPing.mock
}

// Set uses given function f to mock the RedisClient.Ping method
func (mmPing *mRedisClientMockPing) Set(f func(ctx context.Context) (err error)) *RedisClientMock {
	if mmPing.defaultExpectation != nil {
		mmPing.mock.t.Fatalf("Default expectation is already set for the RedisClient.Ping method")
	}

	if len(mmPing.expectations) > 0 {
		mmPing.mock.t.Fatalf("Some expectations are already set for the RedisClient.Ping method")
	}

	mmPing.mock.funcPing = f
	mmPing.mock.funcPingOrigin = minimock.CallerInfo(1)
	return mmPing.mock
}

// When sets expectation for the RedisClient.Ping which will trigger the result defined by the following
// Then helper
func (mmPing *mRedisClientMockPing) When(ctx context.Context) *RedisClientMockPingExpectation {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("RedisClientMock.Ping mock is already set by Set")
	}

	expectation := &RedisClientMockPingExpectation{
		mock:               mmPing.mock,
		params:             &RedisClientMockPingParams{ctx},
		expectationOrigins: RedisClientMockPingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPing.expectations = append(mmPing.expectations, expectation)
	return expectation
}

// Then sets up RedisClient.Ping return parameters for the expectation previously defined by the When method
func (e *RedisClientMockPingExpectation) Then(err error) *RedisClientMock {
	e.results = &RedisClientMockPingResults{err}
	return e.mock
}

// Times sets number of times RedisClient.Ping should be invoked
func (mmPing *mRedisClientMockPing) Times(n uint64) *mRedisClientMockPing {
	if n == 0 {
		mmPing.mock.t.Fatalf("Times of RedisClientMock.Ping mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPing.expectedInvocations, n)
	mmPing.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPing
}

func (mmPing *mRedisClientMockPing) invocationsDone() bool {
	if len(mmPing.expectations) == 0 && mmPing.defaultExpectation == nil && mmPing.mock.funcPing == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPing.mock.afterPingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPing.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Ping implements mm_cache.RedisClient
func (mmPing *RedisClientMock) Ping(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmPing.beforePingCounter, 1)
	defer mm_atomic.AddUint64(&mmPing.afterPingCounter, 1)

	mmPing.t.Helper()

	if mmPing.inspectFuncPing != nil {
		mmPing.inspectFuncPing(ctx)
	}

	mm_params := RedisClientMockPingParams{ctx}

	// Record call args
	mmPing.PingMock.mutex.Lock()
	mmPing.PingMock.callArgs = append(mmPing.PingMock.callArgs, &mm_params)
	mmPing.PingMock.mutex.Unlock()

	for _, e := range mmPing.PingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPing.PingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPing.PingMock.defaultExpectation.Counter, 1)
		mm_want := mmPing.PingMock.defaultExpectation.params
		mm_want_ptrs := mmPing.PingMock.defaultExpectation.paramPtrs

		mm_got := RedisClientMockPingParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPing.t.Errorf("RedisClientMock.Ping got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPing.PingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPing.t.Errorf("RedisClientMock.Ping got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPing.PingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPing.PingMock.defaultExpectation.results
		if mm_results == nil {
			mmPing.t.Fatal("No results are set for the RedisClientMock.Ping")
		}
		return (*mm_results).err
	}
	if mmPing.funcPing != nil {
		return mmPing.funcPing(ctx)
	}
	mmPing.t.Fatalf("Unexpected call to RedisClientMock.Ping. %v", ctx)
	return
}

// PingAfterCounter returns a count of finished RedisClientMock.Ping invocations
func (mmPing *RedisClientMock) PingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPing.afterPingCounter)
}

// PingBeforeCounter returns a count of RedisClientMock.Ping invocations
func (mmPing *RedisClientMock) PingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPing.beforePingCounter)
}

// Calls returns a list of arguments used in each call to RedisClientMock.Ping.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPing *mRedisClientMockPing) Calls() []*RedisClientMockPingParams {
	mmPing.mutex.RLock()

	argCopy := make([]*RedisClientMockPingParams, len(mmPing.callArgs))
	copy(argCopy, mmPing.callArgs)

	mmPing.mutex.RUnlock()

	return argCopy
}

// MinimockPingDone returns true if the count of the Ping invocations corresponds
// the number of defined expectations
func (m *RedisClientMock) MinimockPingDone() bool {
	if m.PingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PingMock.invocationsDone()
}

// MinimockPingInspect logs each unmet expectation
func (m *RedisClientMock) MinimockPingInspect() {
	for _, e := range m.PingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RedisClientMock.Ping at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPingCounter := mm_atomic.LoadUint64(&m.afterPingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PingMock.defaultExpectation != nil && afterPingCounter < 1 {
		if m.PingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RedisClientMock.Ping at\n%s", m.PingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RedisClientMock.Ping at\n%s with params: %#v", m.PingMock.defaultExpectation.expectationOrigins.origin, *m.PingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPing != nil && afterPingCounter < 1 {
		m.t.Errorf("Expected call to RedisClientMock.Ping at\n%s", m.funcPingOrigin)
	}

	if !m.PingMock.invocationsDone() && afterPingCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisClientMock.Ping at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PingMock.expectedInvocations), m.PingMock.expectedInvocationsOrigin, afterPingCounter)
	}
}

type mRedisClientMockSet struct {
	optional           bool
	mock               *RedisClientMock
	defaultExpectation *RedisClientMockSetExpectation
	expectations       []*RedisClientMockSetExpectation

	callArgs []*RedisClientMockSetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RedisClientMockSetExpectation specifies expectation struct of the RedisClient.Set
type RedisClientMockSetExpectation struct {
	mock               *RedisClientMock
	params             *RedisClientMockSetParams
	paramPtrs          *RedisClientMockSetParamPtrs
	expectationOrigins RedisClientMockSetExpectationOrigins
	results            *RedisClientMockSetResults
	returnOrigin       string
	Counter            uint64
}

// RedisClientMockSetParams contains parameters of the RedisClient.Set
type RedisClientMockSetParams struct {
	ctx   context.Context
	key   string
	value interface{}
}

// RedisClientMockSetParamPtrs contains pointers to parameters of the RedisClient.Set
type RedisClientMockSetParamPtrs struct {
	ctx   *context.Context
	key   *string
	value *interface{}
}

// RedisClientMockSetResults contains results of the RedisClient.Set
type RedisClientMockSetResults struct {
	err error
}

// RedisClientMockSetOrigins contains origins of expectations of the RedisClient.Set
type RedisClientMockSetExpectationOrigins struct {
	origin      string
	originCtx   string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSet *mRedisClientMockSet) Optional() *mRedisClientMockSet {
	mmSet.optional = true
	return mmSet
}

// Expect sets up expected params for RedisClient.Set
func (mmSet *mRedisClientMockSet) Expect(ctx context.Context, key string, value interface{}) *mRedisClientMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RedisClientMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &RedisClientMockSetExpectation{}
	}

	if mmSet.defaultExpectation.paramPtrs != nil {
		mmSet.mock.t.Fatalf("RedisClientMock.Set mock is already set by ExpectParams functions")
	}

	mmSet.defaultExpectation.params = &RedisClientMockSetParams{ctx, key, value}
	mmSet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSet.expectations {
		if minimock.Equal(e.params, mmSet.defaultExpectation.params) {
			mmSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSet.defaultExpectation.params)
		}
	}

	return mmSet
}

// ExpectCtxParam1 sets up expected param ctx for RedisClient.Set
func (mmSet *mRedisClientMockSet) ExpectCtxParam1(ctx context.Context) *mRedisClientMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RedisClientMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &RedisClientMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("RedisClientMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &RedisClientMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.ctx = &ctx
	mmSet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSet
}

// ExpectKeyParam2 sets up expected param key for RedisClient.Set
func (mmSet *mRedisClientMockSet) ExpectKeyParam2(key string) *mRedisClientMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RedisClientMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &RedisClientMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("RedisClientMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &RedisClientMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.key = &key
	mmSet.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmSet
}

// ExpectValueParam3 sets up expected param value for RedisClient.Set
func (mmSet *mRedisClientMockSet) ExpectValueParam3(value interface{}) *mRedisClientMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RedisClientMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &RedisClientMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("RedisClientMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &RedisClientMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.value = &value
	mmSet.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmSet
}

// Inspect accepts an inspector function that has same arguments as the RedisClient.Set
func (mmSet *mRedisClientMockSet) Inspect(f func(ctx context.Context, key string, value interface{})) *mRedisClientMockSet {
	if mmSet.mock.inspectFuncSet != nil {
		mmSet.mock.t.Fatalf("Inspect function is already set for RedisClientMock.Set")
	}

	mmSet.mock.inspectFuncSet = f

	return mmSet
}

// Return sets up results that will be returned by RedisClient.Set
func (mmSet *mRedisClientMockSet) Return(err error) *RedisClientMock {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RedisClientMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &RedisClientMockSetExpectation{mock: mmSet.mock}
	}
	mmSet.defaultExpectation.results = &RedisClientMockSetResults{err}
	mmSet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSet.mock
}

// Set uses given function f to mock the RedisClient.Set method
func (mmSet *mRedisClientMockSet) Set(f func(ctx context.Context, key string, value interface{}) (err error)) *RedisClientMock {
	if mmSet.defaultExpectation != nil {
		mmSet.mock.t.Fatalf("Default expectation is already set for the RedisClient.Set method")
	}

	if len(mmSet.expectations) > 0 {
		mmSet.mock.t.Fatalf("Some expectations are already set for the RedisClient.Set method")
	}

	mmSet.mock.funcSet = f
	mmSet.mock.funcSetOrigin = minimock.CallerInfo(1)
	return mmSet.mock
}

// When sets expectation for the RedisClient.Set which will trigger the result defined by the following
// Then helper
func (mmSet *mRedisClientMockSet) When(ctx context.Context, key string, value interface{}) *RedisClientMockSetExpectation {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RedisClientMock.Set mock is already set by Set")
	}

	expectation := &RedisClientMockSetExpectation{
		mock:               mmSet.mock,
		params:             &RedisClientMockSetParams{ctx, key, value},
		expectationOrigins: RedisClientMockSetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSet.expectations = append(mmSet.expectations, expectation)
	return expectation
}

// Then sets up RedisClient.Set return parameters for the expectation previously defined by the When method
func (e *RedisClientMockSetExpectation) Then(err error) *RedisClientMock {
	e.results = &RedisClientMockSetResults{err}
	return e.mock
}

// Times sets number of times RedisClient.Set should be invoked
func (mmSet *mRedisClientMockSet) Times(n uint64) *mRedisClientMockSet {
	if n == 0 {
		mmSet.mock.t.Fatalf("Times of RedisClientMock.Set mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSet.expectedInvocations, n)
	mmSet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSet
}

func (mmSet *mRedisClientMockSet) invocationsDone() bool {
	if len(mmSet.expectations) == 0 && mmSet.defaultExpectation == nil && mmSet.mock.funcSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSet.mock.afterSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Set implements mm_cache.RedisClient
func (mmSet *RedisClientMock) Set(ctx context.Context, key string, value interface{}) (err error) {
	mm_atomic.AddUint64(&mmSet.beforeSetCounter, 1)
	defer mm_atomic.AddUint64(&mmSet.afterSetCounter, 1)

	mmSet.t.Helper()

	if mmSet.inspectFuncSet != nil {
		mmSet.inspectFuncSet(ctx, key, value)
	}

	mm_params := RedisClientMockSetParams{ctx, key, value}

	// Record call args
	mmSet.SetMock.mutex.Lock()
	mmSet.SetMock.callArgs = append(mmSet.SetMock.callArgs, &mm_params)
	mmSet.SetMock.mutex.Unlock()

	for _, e := range mmSet.SetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSet.SetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSet.SetMock.defaultExpectation.Counter, 1)
		mm_want := mmSet.SetMock.defaultExpectation.params
		mm_want_ptrs := mmSet.SetMock.defaultExpectation.paramPtrs

		mm_got := RedisClientMockSetParams{ctx, key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSet.t.Errorf("RedisClientMock.Set got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSet.SetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmSet.t.Errorf("RedisClientMock.Set got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSet.SetMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSet.t.Errorf("RedisClientMock.Set got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSet.SetMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSet.t.Errorf("RedisClientMock.Set got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSet.SetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSet.SetMock.defaultExpectation.results
		if mm_results == nil {
			mmSet.t.Fatal("No results are set for the RedisClientMock.Set")
		}
		return (*mm_results).err
	}
	if mmSet.funcSet != nil {
		return mmSet.funcSet(ctx, key, value)
	}
	mmSet.t.Fatalf("Unexpected call to RedisClientMock.Set. %v %v %v", ctx, key, value)
	return
}

// SetAfterCounter returns a count of finished RedisClientMock.Set invocations
func (mmSet *RedisClientMock) SetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.afterSetCounter)
}

// SetBeforeCounter returns a count of RedisClientMock.Set invocations
func (mmSet *RedisClientMock) SetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.beforeSetCounter)
}

// Calls returns a list of arguments used in each call to RedisClientMock.Set.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSet *mRedisClientMockSet) Calls() []*RedisClientMockSetParams {
	mmSet.mutex.RLock()

	argCopy := make([]*RedisClientMockSetParams, len(mmSet.callArgs))
	copy(argCopy, mmSet.callArgs)

	mmSet.mutex.RUnlock()

	return argCopy
}

// MinimockSetDone returns true if the count of the Set invocations corresponds
// the number of defined expectations
func (m *RedisClientMock) MinimockSetDone() bool {
	if m.SetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetMock.invocationsDone()
}

// MinimockSetInspect logs each unmet expectation
func (m *RedisClientMock) MinimockSetInspect() {
	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RedisClientMock.Set at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetCounter := mm_atomic.LoadUint64(&m.afterSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetMock.defaultExpectation != nil && afterSetCounter < 1 {
		if m.SetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RedisClientMock.Set at\n%s", m.SetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RedisClientMock.Set at\n%s with params: %#v", m.SetMock.defaultExpectation.expectationOrigins.origin, *m.SetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSet != nil && afterSetCounter < 1 {
		m.t.Errorf("Expected call to RedisClientMock.Set at\n%s", m.funcSetOrigin)
	}

	if !m.SetMock.invocationsDone() && afterSetCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisClientMock.Set at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetMock.expectedInvocations), m.SetMock.expectedInvocationsOrigin, afterSetCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RedisClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockExpireInspect()

			m.MinimockGetInspect()

			m.MinimockHGetAllInspect()

			m.MinimockHashSetInspect()

			m.MinimockPingInspect()

			m.MinimockSetInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RedisClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RedisClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockExpireDone() &&
		m.MinimockGetDone() &&
		m.MinimockHGetAllDone() &&
		m.MinimockHashSetDone() &&
		m.MinimockPingDone() &&
		m.MinimockSetDone()
}
